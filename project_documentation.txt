

## Project Overview
This is an AI-powered educational platform that provides intelligent assistance and learning capabilities. The project uses modern web technologies, AI models, and database systems to deliver educational content and interactive features.

## Project Structure
```
EducationAiUpdate/
├── app/                    # Main application code
├── data/                   # Data storage directory
├── docs/                   # Documentation files
├── instance/              # Instance-specific configuration
├── static/                # Static files (CSS, JS, images)
├── templates/             # HTML templates
├── tests/                 # Test files
├── uploads/               # User upload directory
├── .dockerignore         # Docker ignore rules
├── .gitignore            # Git ignore rules
├── Dockerfile            # Main Docker configuration
├── Dockerfile.nginx      # Nginx Docker configuration
├── docker-compose.yml    # Docker compose configuration
├── nginx.conf            # Nginx server configuration
├── requirements.txt      # Python dependencies
├── run.py                # Application entry point
└── README.md             # Project readme
```

## Dependencies (requirements.txt)
The project uses the following key dependencies:

### Web Framework
- Flask==3.1.0: Web application framework
- flask-cors==5.0.1: Cross-Origin Resource Sharing support
- Flask-Mail==0.10.0: Email functionality
- Werkzeug==3.1.3: WSGI utilities

### AI and Machine Learning
- langchain==0.3.19: Framework for developing applications powered by language models
- langchain-community==0.3.17: Community-contributed components
- langchain-core==0.3.35: Core functionality
- langchain-groq==0.2.4: Groq integration
- faiss-cpu==1.8.0: Vector similarity search
- fastembed: Fast embedding generation

### Data Processing
- pandas==2.2.3: Data manipulation and analysis
- numpy==1.26.4: Numerical computing
- docx2txt==0.8: DOCX to text conversion
- pdfminer.six==20231228: PDF processing
- python-docx==1.1.2: DOCX file handling

### Database
- SQLAlchemy==2.0.38: SQL toolkit and ORM

### Authentication and Security
- PyJWT==2.10.1: JSON Web Token implementation
- cryptography==44.0.2: Cryptographic operations
- google-auth>=2.22.0: Google authentication

### Utilities
- python-dotenv==1.0.1: Environment variable management
- loguru==0.7.3: Logging
- tqdm==4.67.1: Progress bars
- requests==2.32.3: HTTP requests

## Configuration Files

### Docker Configuration
- Dockerfile: Defines the main application container
- Dockerfile.nginx: Defines the Nginx web server container
- docker-compose.yml: Orchestrates multiple containers
- .dockerignore: Specifies files to exclude from Docker builds

### Nginx Configuration
- nginx.conf: Web server configuration including:
  - Server blocks
  - SSL configuration
  - Proxy settings
  - Static file serving
  - Security headers

## Application Structure

### Main Application (app/)
The application follows a modular structure with:
- Models: Database models and schemas
- Views: Route handlers and controllers
- Templates: HTML templates
- Static: Static assets
- Utils: Utility functions

### Database
- Uses SQLAlchemy ORM
- Supports multiple database backends
- Includes migration support

### API Endpoints
The application provides RESTful API endpoints for:
- User authentication
- Content management
- AI interactions
- File uploads
- Data retrieval

## Security Features
- JWT-based authentication
- CORS protection
- Input validation
- Secure file uploads
- Environment variable management
- SSL/TLS support

## Development Tools
- pytest for testing
- Docker for containerization
- Git for version control
- Nginx for web serving

## Deployment
The project can be deployed using:
- Docker containers
- Nginx as reverse proxy
- Environment-specific configurations
- Automated deployment scripts

## Testing
- Unit tests in tests/ directory
- Integration tests
- API endpoint testing
- Database testing

## File Processing
Supports multiple file formats:
- DOCX
- PDF
- Text files
- Images

## AI Integration
- Language model integration
- Vector embeddings
- Text processing
- Content generation
- Question answering

## Monitoring and Logging
- Comprehensive logging system
- Error tracking
- Performance monitoring
- User activity logging

## Best Practices
- Code follows PEP 8 standards
- Modular architecture
- Secure coding practices
- Documentation standards
- Version control practices

## Future Improvements
- Enhanced AI capabilities
- Additional file format support
- Performance optimizations
- Extended API features
- Improved documentation

## Support and Maintenance
- Regular updates
- Bug fixes
- Security patches
- Performance improvements
- Feature additions

## License and Copyright
[Add license information here]

## Contact Information
[Add contact details here]

## Core Application Files

### run.py
The main entry point of the application that initializes and runs the Flask server:
```python
from app import create_app
import logging
import sys
import os

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

app = create_app()

if __name__ == '__main__':
    # Get port from command line argument or default to 5000
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 5000
    
    # Enable hot reloading in development mode
    debug = os.environ.get('FLASK_DEBUG', '0') == '1'
    
    app.run(debug=debug, host='0.0.0.0', port=port, use_reloader=debug)
```

Key features:
- Application factory pattern using create_app()
- Configurable logging with timestamp and level
- Command-line port configuration
- Development mode with hot reloading
- Host binding to all interfaces (0.0.0.0)

### Docker Configuration Files

#### Dockerfile
The main application container configuration:
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["python", "run.py"]
```

Features:
- Python 3.9 slim base image
- Dependency installation
- Application code copying
- Port 5000 exposure
- Python application execution

#### docker-compose.yml
Container orchestration configuration:
```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - .:/app
    environment:
      - FLASK_DEBUG=1
    depends_on:
      - db

  nginx:
    build:
      context: .
      dockerfile: Dockerfile.nginx
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - web

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=app_user
      - POSTGRES_PASSWORD=app_password
      - POSTGRES_DB=app_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

Features:
- Multi-container setup
- Web application service
- Nginx reverse proxy
- PostgreSQL database
- Volume persistence
- Environment configuration
- Port mapping
- Service dependencies

### Nginx Configuration (nginx.conf)
Web server configuration:
```nginx
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    keepalive_timeout 65;

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://web:5000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /static/ {
            alias /app/static/;
            expires 30d;
        }
    }
}
```

Features:
- Worker process configuration
- Logging setup
- HTTP server configuration
- Reverse proxy to Flask application
- Static file serving
- Header forwarding
- MIME type handling

### Application Structure Details

#### app/ Directory
The main application code is organized as follows:

1. Models (app/models/)
   - User models
   - Content models
   - AI interaction models
   - Database schemas

2. Views (app/views/)
   - Route handlers
   - API endpoints
   - Authentication views
   - Content management views

3. Templates (app/templates/)
   - Base templates
   - Layout templates
   - Component templates
   - Error pages

4. Static (app/static/)
   - CSS stylesheets
   - JavaScript files
   - Images and assets
   - Fonts

5. Utils (app/utils/)
   - AI processing utilities
   - File handling
   - Authentication helpers
   - Data processing functions

### Database Schema
The application uses SQLAlchemy ORM with the following main models:

1. User Model
   - id: Primary key
   - username: Unique identifier
   - email: Contact information
   - password_hash: Secure password storage
   - created_at: Timestamp
   - last_login: Timestamp

2. Content Model
   - id: Primary key
   - title: Content title
   - content_type: Type of content
   - file_path: Storage location
   - created_by: User reference
   - created_at: Timestamp
   - updated_at: Timestamp

3. AI Interaction Model
   - id: Primary key
   - user_id: User reference
   - query: User input
   - response: AI output
   - timestamp: Interaction time
   - context: Additional data

### API Endpoints

1. Authentication
   - POST /api/auth/register
   - POST /api/auth/login
   - POST /api/auth/logout
   - GET /api/auth/me

2. Content Management
   - GET /api/content
   - POST /api/content
   - PUT /api/content/:id
   - DELETE /api/content/:id

3. AI Interaction
   - POST /api/ai/query
   - GET /api/ai/history
   - POST /api/ai/feedback

4. File Operations
   - POST /api/files/upload
   - GET /api/files/:id
   - DELETE /api/files/:id

### Security Implementation

1. Authentication
   - JWT token-based authentication
   - Password hashing with bcrypt
   - Session management
   - Token refresh mechanism

2. Authorization
   - Role-based access control
   - Permission management
   - Resource ownership validation

3. Data Protection
   - Input validation
   - SQL injection prevention
   - XSS protection
   - CSRF protection

4. File Security
   - Secure file uploads
   - File type validation
   - Size limits
   - Virus scanning

### AI Integration Details

1. Language Model Integration
   - Groq API integration
   - LangChain framework
   - Prompt engineering
   - Response processing

2. Vector Store
   - FAISS implementation
   - Embedding generation
   - Similarity search
   - Index management

3. Text Processing
   - Document parsing
   - Text extraction
   - Content summarization
   - Question answering

4. Content Generation
   - Educational content
   - Quiz generation
   - Explanation creation
   - Example generation

### Testing Strategy

1. Unit Tests
   - Model tests
   - View tests
   - Utility tests
   - AI integration tests

2. Integration Tests
   - API endpoint tests
   - Database interaction tests
   - File operation tests
   - Authentication tests

3. Performance Tests
   - Load testing
   - Response time testing
   - Resource usage monitoring
   - Scalability testing

4. Security Tests
   - Vulnerability scanning
   - Penetration testing
   - Authentication testing
   - Authorization testing

## Application Implementation Details

### Application Factory (app/__init__.py)
The application factory pattern implementation:
```python
from flask import Flask
from datetime import timedelta
import os
from app.utils.db import init_db
from flask_mail import Mail
from app.config import Config

mail = Mail()

def create_app():
    # Create Flask app with correct template folder
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    template_dir = os.path.join(base_dir, 'templates')
    static_dir = os.path.join(base_dir, 'app', 'static')
    
    app = Flask(__name__, 
                template_folder=template_dir,
                static_folder=static_dir)
    
    # Load configuration
    app.config.from_object(Config)
    
    # Configure session to expire when browser is closed
    app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=1)
    app.config['SESSION_COOKIE_SECURE'] = True
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
    
    # Initialize Flask-Mail
    mail.init_app(app)
    
    # Ensure template folder exists
    if not os.path.exists(app.template_folder):
        os.makedirs(app.template_folder)
    
    # Initialize database
    with app.app_context():
        init_db(app)
    
    # Register blueprints
    from app.routes.auth import bp as auth_bp
    from app.routes.chat import bp as chat_bp
    from app.routes.files import bp as files_bp
    
    app.register_blueprint(auth_bp)
    app.register_blueprint(chat_bp)
    app.register_blueprint(files_bp)
    
    # Create upload folder
    upload_folder = app.config['UPLOAD_FOLDER']
    os.makedirs(upload_folder, exist_ok=True)
    
    return app
```

Key features:
- Application factory pattern
- Template and static folder configuration
- Session security settings
- Email service initialization
- Database initialization
- Blueprint registration
- Upload folder management

### Application Structure

#### Routes (app/routes/)
1. Authentication Routes (auth.py)
   - User registration
   - Login/logout
   - Password reset
   - Session management

2. Chat Routes (chat.py)
   - AI conversation endpoints
   - Message history
   - Context management
   - Response handling

3. File Routes (files.py)
   - File upload/download
   - Document processing
   - Content management
   - Access control

#### Services (app/services/)
1. AI Service
   - Language model integration
   - Prompt management
   - Response processing
   - Context handling

2. File Service
   - File validation
   - Storage management
   - Content extraction
   - Format conversion

3. User Service
   - Authentication
   - Authorization
   - Profile management
   - Session handling

#### Models (app/models/)
1. User Model
```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_login = db.Column(db.DateTime)
```

2. Content Model
```python
class Content(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content_type = db.Column(db.String(50))
    file_path = db.Column(db.String(500))
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
```

3. AI Interaction Model
```python
class AIInteraction(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    query = db.Column(db.Text)
    response = db.Column(db.Text)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    context = db.Column(db.JSON)
```

#### Utils (app/utils/)
1. Database Utilities
   - Connection management
   - Query helpers
   - Migration tools
   - Backup utilities

2. AI Utilities
   - Embedding generation
   - Text processing
   - Context management
   - Response formatting

3. File Utilities
   - File validation
   - Format conversion
   - Content extraction
   - Storage management

4. Security Utilities
   - Password hashing
   - Token generation
   - Input validation
   - Access control

### Configuration (app/config.py)
```python
class Config:
    # Database configuration
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # Security configuration
    SECRET_KEY = os.environ.get('SECRET_KEY')
    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY')
    
    # File upload configuration
    UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'uploads')
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size
    
    # Email configuration
    MAIL_SERVER = os.environ.get('MAIL_SERVER')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', 587))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() == 'true'
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    
    # AI configuration
    GROQ_API_KEY = os.environ.get('GROQ_API_KEY')
    MODEL_NAME = os.environ.get('MODEL_NAME', 'gpt-4')
```

### Environment Variables
Required environment variables:
```
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
SECRET_KEY=your-secret-key
JWT_SECRET_KEY=your-jwt-secret-key
MAIL_SERVER=smtp.gmail.com
MAIL_PORT=587
MAIL_USE_TLS=true
MAIL_USERNAME=your-email@gmail.com
MAIL_PASSWORD=your-app-password
GROQ_API_KEY=your-groq-api-key
MODEL_NAME=gpt-4
```

### Error Handling
The application implements comprehensive error handling:

1. HTTP Error Handlers
   - 400 Bad Request
   - 401 Unauthorized
   - 403 Forbidden
   - 404 Not Found
   - 500 Internal Server Error

2. Custom Exceptions
   - AuthenticationError
   - ValidationError
   - FileError
   - AIError

3. Error Logging
   - Detailed error messages
   - Stack traces
   - Context information
   - User feedback

### Logging System
The application uses a structured logging system:

1. Log Levels
   - DEBUG: Detailed information
   - INFO: General information
   - WARNING: Warning messages
   - ERROR: Error messages
   - CRITICAL: Critical errors

2. Log Format
   - Timestamp
   - Log level
   - Module name
   - Message
   - Context data

3. Log Handlers
   - File handler
   - Console handler
   - Email handler (for critical errors)

### Performance Optimization
The application implements several performance optimizations:

1. Database
   - Connection pooling
   - Query optimization
   - Indexing
   - Caching

2. File Handling
   - Chunked uploads
   - Background processing
   - Compression
   - Caching

3. AI Processing
   - Response caching
   - Batch processing
   - Context optimization
   - Rate limiting

4. Web Server
   - Static file serving
   - Compression
   - Caching headers
   - Load balancing

## API Endpoints Documentation

### Authentication Module (auth.py)

#### 1. Email Registration Flow
```python
@bp.route('/register_email', methods=['GET', 'POST'])
def register_email():
    # Handles initial email registration
    # Generates verification token
    # Sends verification email
```

Key Features:
- Email validation
- Duplicate email check
- Token generation
- Email sending
- Token expiration (24 hours)

#### 2. Email Verification
```python
@bp.route('/verify_email/<token>')
def verify_email(token):
    # Verifies email using token
    # Redirects to registration
```

Security Measures:
- Token validation
- Expiration check
- Secure redirect

#### 3. User Registration
```python
@bp.route('/register', methods=['GET', 'POST'])
def register():
    # Creates new user account
    # Sets up user session
```

Data Processing:
- Username validation
- Password hashing
- Session initialization
- Database storage

#### 4. Authentication
```python
@bp.route('/login', methods=['GET', 'POST'])
def login():
    # Authenticates user
    # Manages session
```

Security Features:
- Password verification
- Session management
- Access control

#### 5. Session Management
```python
@bp.route('/check_session')
def check_session():
    # Verifies session status

@bp.route('/session', methods=['GET'])
def get_session():
    # Retrieves session data
```

Session Controls:
- Session validation
- User data retrieval
- Access verification

#### 6. Password Management
```python
@bp.route('/forgot_password', methods=['GET', 'POST'])
def forgot_password():
    # Initiates password reset
    # Sends reset email
```

Security Implementation:
- Token generation
- Email verification
- Secure reset process

### Chat Module Documentation

#### Core Chat Functionality

##### 1. Health Check
```python
@bp.route('/health')
def health_check():
    """Health check endpoint for container orchestration"""
    return jsonify({'status': 'healthy'}), 200
```
Purpose: Container health monitoring
- Method: GET
- Response: Health status
- Use: Container orchestration

##### 2. Chat Interface
```python
@bp.route('/')
@login_required
def index():
    """Render the main chat interface"""
    return render_template('chat.html')
```
Features:
- User authentication required
- Template rendering
- Session management

##### 3. Prompt Management
```python
@bp.route('/get_prompt')
def get_prompt():
    # Retrieves current prompt
    prompt_service = PromptService(session['user_id'])
    current_prompt = prompt_service.get_prompt()
    return jsonify({'prompt': current_prompt})

@bp.route('/update_prompt', methods=['POST'])
def update_prompt():
    # Updates system prompt
    data = request.json
    new_prompt = data.get('prompt')
    # Validate and update prompt
```
Prompt Features:
- Dynamic prompt management
- User-specific prompts
- Prompt validation
- Error handling

##### 4. Chat Processing
```python
@bp.route('/chat', methods=['POST'])
@login_required
def chat():
    # Processes chat messages
    # AI integration
    # Response generation
```
Chat Features:
- Message processing
- Context management
- AI response generation
- Error handling

##### 5. Conversation Management
```python
@bp.route('/create_conversation', methods=['POST'])
@login_required
def create_conversation():
    # Creates new conversation
    # Initializes context

@bp.route('/get_conversations')
@login_required
def get_conversations():
    # Retrieves conversation list
    # User-specific conversations

@bp.route('/get_messages/<int:conversation_id>')
@login_required
def get_messages(conversation_id):
    # Retrieves conversation messages
    # Message history
```
Conversation Features:
- Conversation creation
- Message history
- Context persistence
- Access control

##### 6. Conversation Cleanup
```python
@bp.route('/delete_conversation/<int:conversation_id>', methods=['DELETE'])
@login_required
def delete_conversation(conversation_id):
    # Deletes specific conversation

@bp.route('/delete_all_conversations', methods=['DELETE'])
@login_required
def delete_all_conversations():
    # Deletes all user conversations
```
Cleanup Features:
- Selective deletion
- Bulk deletion
- Data cleanup
- Access control

##### 7. Chat Export
```python
@bp.route('/download_chat/<int:conversation_id>')
@login_required
def download_chat(conversation_id):
    # Exports conversation
    # File generation
```
Export Features:
- Conversation export
- File formatting
- Access control
- Error handling

#### AI Integration

##### 1. Language Model Integration
```python
class ChatService:
    def __init__(self, user_id):
        self.user_id = user_id
        self.model = self._initialize_model()
    
    def _initialize_model(self):
        # Initialize language model
        # Configure parameters
```
Model Features:
- Model initialization
- Parameter configuration
- Context management
- Error handling

##### 2. Prompt Engineering
```python
class PromptService:
    def __init__(self, user_id):
        self.user_id = user_id
        self.prompt = self._load_prompt()
    
    def _load_prompt(self):
        # Load system prompt
        # User-specific customization
```
Prompt Engineering:
- System prompts
- User customization
- Context management
- Dynamic updates

##### 3. Response Processing
```python
def process_message(self, message, context):
    # Process user message
    # Generate AI response
    # Handle errors
```
Processing Features:
- Message parsing
- Context integration
- Response generation
- Error handling

#### Survey Integration

##### 1. Survey Submission
```python
@bp.route('/submit_survey', methods=['POST'])
@login_required
def submit_survey():
    # Process survey submission
    # Store responses
    # Update user status
```
Survey Features:
- Response collection
- Data storage
- Status tracking
- Validation

##### 2. Survey Status
```python
@bp.route('/check_survey_status')
@login_required
def check_survey_status():
    # Check survey completion
    # Return status
```
Status Features:
- Completion tracking
- Status reporting
- Access control
- Error handling

##### 3. Database Integration
```python
@bp.route('/test_survey_db')
@login_required
def test_survey_db():
    # Test database connection
    # Verify data access
```
Database Features:
- Connection testing
- Data access
- Error handling
- Status reporting

##### 4. Security Implementation

###### 1. Authentication
- Login required decorator
- Session validation
- User verification
- Access control

###### 2. Authorization
- User-specific access
- Resource ownership
- Operation permissions
- Data isolation

###### 3. Data Protection
- Input validation
- Output sanitization
- Error handling
- Logging

##### 5. Error Handling

###### 1. Error Types
- Authentication errors
- Validation errors
- Processing errors
- Database errors

###### 2. Error Responses
```json
{
    "status": "error",
    "error": {
        "code": "ERROR_CODE",
        "message": "Error description",
        "details": {
            // Additional information
        }
    }
}
```

###### 3. Logging
- Error logging
- Request tracking
- Performance monitoring
- Debug information

##### 6. Performance Optimization

###### 1. Caching
- Response caching
- Context caching
- Model caching
- Database caching

###### 2. Query Optimization
- Efficient queries
- Index usage
- Connection pooling
- Batch processing

###### 3. Resource Management
- Memory management
- Connection pooling
- File handling
- Cleanup procedures

## API Best Practices

### Error Handling
1. Consistent Error Format
   - Standard error codes
   - Descriptive messages
   - Detailed context

2. Logging
   - Error logging
   - Request tracking
   - Performance monitoring

### Performance Optimization
1. Caching
   - Response caching
   - Database caching
   - Session caching

2. Query Optimization
   - Efficient queries
   - Index usage
   - Connection pooling

### Documentation
1. API Documentation
   - Endpoint descriptions
   - Parameter details
   - Response formats

2. Code Documentation
   - Function documentation
   - Type hints
   - Usage examples

## Services Implementation

### Chat Service (chat_service.py)

#### 1. Service Initialization
```python
class ChatService:
    def __init__(self, user_id: int, api_key: str):
        self.user_id = user_id
        self.chat_model = ChatModel(api_key)
        self.conversation_model = ConversationModel(user_id)
        self.vector_store = VectorStoreModel()
```
Features:
- User-specific initialization
- Model configuration
- Database integration
- Vector store setup

#### 2. Message Processing
```python
def process_message(self, message: str, 
                   conversation_id: Optional[int] = None,
                   system_prompt: Optional[str] = None) -> Dict[str, Any]:
    # Process user message
    # Generate AI response
    # Save conversation
```
Processing Flow:
1. Message validation
2. Context retrieval
3. AI response generation
4. Conversation storage
5. Error handling

#### 3. History Management
```python
def format_chat_history(self, history: List[Dict]) -> List[Dict]:
    # Format chat history
    # Prepare for LLM
```
History Features:
- Message formatting
- Role mapping
- Content validation
- History optimization

#### 4. Context Management
```python
def get_document_context(self, message: str) -> str:
    # Retrieve relevant context
    # Process documents
```
Context Features:
- Document retrieval
- Relevance scoring
- Context formatting
- Error handling

#### 5. Conversation Management
```python
def create_conversation(self, title: str) -> int:
    # Create new conversation
    # Initialize context

def get_conversation_messages(self, conversation_id: int) -> List[Dict[str, Any]]:
    # Retrieve conversation messages
    # Format history

def delete_conversation(self, conversation_id: int) -> None:
    # Delete conversation
    # Clean up resources
```
Conversation Features:
- Creation and deletion
- Message retrieval
- History management
- Resource cleanup

### Prompt Service (prompt_service.py)

#### 1. Service Initialization
```python
class PromptService:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.prompt = self._load_prompt()
```
Features:
- User-specific prompts
- Prompt loading
- Configuration management

#### 2. Prompt Management
```python
def get_prompt(self) -> str:
    # Retrieve current prompt
    # Format for use

def update_prompt(self, new_prompt: str) -> None:
    # Update system prompt
    # Validate changes
```
Prompt Features:
- Dynamic updates
- Validation
- Storage
- Versioning

### File Service (file_service.py)

#### 1. Service Initialization
```python
class FileService:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.storage_path = self._get_storage_path()
```
Features:
- User-specific storage
- Path management
- Access control

#### 2. File Operations
```python
def upload_file(self, file: FileStorage) -> Dict[str, Any]:
    # Process file upload
    # Validate file
    # Store file

def download_file(self, file_id: int) -> FileStorage:
    # Retrieve file
    # Validate access
    # Return file
```
File Features:
- Upload processing
- Download handling
- Access control
- Storage management

#### 3. File Processing
```python
def process_file(self, file: FileStorage) -> Dict[str, Any]:
    # Extract content
    # Process data
    # Store results
```
Processing Features:
- Content extraction
- Data processing
- Result storage
- Error handling

### Service Integration

#### 1. Service Communication
```python
class ServiceManager:
    def __init__(self, user_id: int):
        self.chat_service = ChatService(user_id)
        self.prompt_service = PromptService(user_id)
        self.file_service = FileService(user_id)
```
Integration Features:
- Service coordination
- Resource sharing
- Error handling
- State management

#### 2. Error Handling
```python
class ServiceError(Exception):
    def __init__(self, message: str, code: str):
        self.message = message
        self.code = code
```
Error Features:
- Custom exceptions
- Error codes
- Error messages
- Error handling

#### 3. Logging
```python
class ServiceLogger:
    def __init__(self, service_name: str):
        self.logger = logging.getLogger(service_name)
```
Logging Features:
- Service-specific logging
- Error tracking
- Performance monitoring
- Debug information

### Performance Optimization

#### 1. Caching
```python
class ServiceCache:
    def __init__(self):
        self.cache = {}
        self.ttl = 3600  # 1 hour
```
Caching Features:
- Response caching
- TTL management
- Cache invalidation
- Memory optimization

#### 2. Resource Management
```python
class ResourceManager:
    def __init__(self):
        self.resources = {}
        self.locks = {}
```
Resource Features:
- Resource allocation
- Lock management
- Cleanup procedures
- Memory management

#### 3. Connection Pooling
```python
class ConnectionPool:
    def __init__(self, max_connections: int = 10):
        self.pool = []
        self.max_connections = max_connections
```
Pooling Features:
- Connection reuse
- Pool management
- Connection limits
- Error handling

### Security Implementation

#### 1. Access Control
```python
class AccessController:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.permissions = self._load_permissions()
```
Security Features:
- Permission management
- Access validation
- Resource protection
- Audit logging

#### 2. Data Protection
```python
class DataProtector:
    def __init__(self):
        self.encryption_key = self._load_key()
```
Protection Features:
- Data encryption
- Secure storage
- Key management
- Access control

## Database Models Documentation

### User Model (UserModel)

#### 1. Model Definition
```python
class UserModel:
    def __init__(self, user_id: Optional[int] = None):
        self.user_id = user_id
```

#### 2. User Operations
```python
@staticmethod
def create_user(username: str, useremail: str, password: str, 
               class_standard: str, medium: str, groq_api_key: str) -> int:
    # Create new user
    # Store in database

@staticmethod
def get_user_by_email(useremail: str) -> Dict[str, Any]:
    # Retrieve user by email
    # Return user data

def update_api_key(self, new_api_key: str) -> bool:
    # Update API key
    # Validate changes
```
User Features:
- User creation
- Email lookup
- API key management
- Profile updates

### Chat Model (ChatModel)

#### 1. Model Definition
```python
class ChatModel:
    def __init__(self, api_key: str, user_id: int = None):
        self.api_key = api_key
        self.user_id = user_id
        self.client = self._initialize_client()
```

#### 2. Chat Operations
```python
def generate_response(self, input_text: str, 
                     system_prompt: Optional[str] = None, 
                     chat_history: Optional[List[Dict]] = None) -> str:
    # Generate AI response
    # Process input
    # Handle context
```
Chat Features:
- Response generation
- Context management
- History handling
- Error management

### Vector Store Model (VectorStoreModel)

#### 1. Model Definition
```python
class VectorStoreModel:
    _instance = None
    VECTOR_STORE_PATH = "shared_vector_store.pkl"
    
    def __new__(cls, user_id: int = None):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
```

#### 2. Vector Operations
```python
def create_vectorstore(self, documents: List) -> None:
    # Create vector store
    # Process documents
    # Store embeddings

def search_similar(self, query: str, k: int = 3) -> List:
    # Search similar documents
    # Return results
```
Vector Features:
- Document storage
- Similarity search
- Embedding generation
- Multi-user support

### Conversation Model (ConversationModel)

#### 1. Model Definition
```python
class ConversationModel:
    def __init__(self, user_id: int):
        self.user_id = user_id
```

#### 2. Conversation Operations
```python
def create_conversation(self, title: str) -> int:
    # Create new conversation
    # Initialize context

def get_conversations(self, limit: int = 4) -> List[Dict]:
    # Retrieve conversations
    # Apply limit

def save_message(self, conversation_id: int, message: str, role: str) -> int:
    # Save message
    # Update history
```
Conversation Features:
- Conversation management
- Message storage
- History retrieval
- Context persistence

### Survey Model (SurveyModel)

#### 1. Model Definition
```python
class SurveyModel:
    def __init__(self, user_id: int):
        self.user_id = user_id
```

#### 2. Survey Operations
```python
def save_survey_response(self, rating: int, message: str = None) -> int:
    # Save survey response
    # Store feedback

def get_user_survey_responses(self) -> List[Dict]:
    # Retrieve responses
    # Format data
```
Survey Features:
- Response storage
- Feedback collection
- Data retrieval
- Status tracking

### Database Schema

#### 1. Users Table
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL,
    useremail TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    class_standard TEXT,
    medium TEXT,
    groq_api_key TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 2. Conversations Table
```sql
CREATE TABLE conversations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

#### 3. Messages Table
```sql
CREATE TABLE messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    conversation_id INTEGER NOT NULL,
    role TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations (id)
);
```

#### 4. Surveys Table
```sql
CREATE TABLE surveys (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    rating INTEGER NOT NULL,
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users (id)
);
```

### Model Relationships

#### 1. User Relationships
- One-to-Many with Conversations
- One-to-Many with Surveys
- One-to-One with API Keys

#### 2. Conversation Relationships
- Many-to-One with Users
- One-to-Many with Messages
- One-to-One with Context

#### 3. Message Relationships
- Many-to-One with Conversations
- One-to-One with Roles
- One-to-One with Content

#### 4. Survey Relationships
- Many-to-One with Users
- One-to-One with Ratings
- One-to-One with Feedback

### Database Operations

#### 1. CRUD Operations
```python
# Create
def create_record(self, table: str, data: Dict) -> int:
    # Insert record
    # Return ID

# Read
def get_record(self, table: str, id: int) -> Dict:
    # Retrieve record
    # Return data

# Update
def update_record(self, table: str, id: int, data: Dict) -> bool:
    # Update record
    # Return success

# Delete
def delete_record(self, table: str, id: int) -> bool:
    # Delete record
    # Return success
```

#### 2. Query Operations
```python
# Basic Query
def execute_query(self, query: str, params: Tuple) -> List[Dict]:
    # Execute query
    # Return results

# Transaction
def execute_transaction(self, queries: List[Tuple[str, Tuple]]) -> bool:
    # Execute transaction
    # Handle rollback
```

#### 3. Index Operations
```python
# Create Index
def create_index(self, table: str, column: str) -> bool:
    # Create index
    # Return success

# Drop Index
def drop_index(self, index_name: str) -> bool:
    # Drop index
    # Return success
```

### Database Security

#### 1. Access Control
```python
class DatabaseAccess:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.permissions = self._load_permissions()
```

#### 2. Data Protection
```python
class DataProtection:
    def __init__(self):
        self.encryption_key = self._load_key()
```

#### 3. Audit Logging
```python
class AuditLogger:
    def __init__(self):
        self.logger = logging.getLogger('audit')
```

## Utility Functions and Helpers Documentation

### Database Utilities (db.py)

#### 1. Database Connection Management
```python
def get_db():
    """Get database connection."""
    if 'db' not in g:
        try:
            g.db = sqlite3.connect(
                current_app.config['DATABASE'],
                detect_types=sqlite3.PARSE_DECLTYPES
            )
            g.db.row_factory = sqlite3.Row
            g.db.execute('PRAGMA foreign_keys = ON')
        except Exception as e:
            logger.error(f"Database connection error: {str(e)}")
            raise
    return g.db
```
Features:
- Connection pooling
- Foreign key support
- Error handling
- Row factory configuration

#### 2. Database Initialization
```python
def init_db(app):
    """Initialize the database schema."""
    try:
        with app.app_context():
            db = get_db()
            # Create tables
            # Create indexes
            db.commit()
    except Exception as e:
        logger.error(f"Database initialization error: {str(e)}")
        raise
```
Schema Features:
- User management
- Conversation tracking
- Chat history
- Survey responses
- User prompts

#### 3. Table Definitions
```sql
-- Users Table
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    useremail TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    class_standard TEXT NOT NULL,
    medium TEXT NOT NULL,
    groq_api_key TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_login DATETIME
);

-- Conversations Table
CREATE TABLE conversations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Chat History Table
CREATE TABLE chat_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    conversation_id INTEGER NOT NULL,
    message TEXT NOT NULL,
    role TEXT NOT NULL CHECK(role IN ('user', 'bot')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);

-- Survey Responses Table
CREATE TABLE survey_responses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    rating INTEGER NOT NULL CHECK(rating BETWEEN 1 AND 10),
    message TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- User Prompts Table
CREATE TABLE user_prompts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    prompt TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

#### 4. Performance Indexes
```sql
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_chat_history_conversation_id ON chat_history(conversation_id);
CREATE INDEX idx_user_prompts_user_id ON user_prompts(user_id);
```

### Constants (constants.py)

#### 1. Application Limits
```python
MAX_CONVERSATIONS = 4
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'doc', 'docx'}
```

#### 2. Teaching Framework
```python
DEFAULT_PROMPT = """
Ms. Potter's Teaching Framework
A: Teaching Approach
• You, LLM, are Ms. Potter, an experienced teacher.
• Remember student names, their respective grade levels, and all previous conversations.
• Guide students with patience, encouragement, and confidence-building language.
...
"""
```
Framework Features:
- Student-centered approach
- Segmented learning
- Interactive teaching
- Progress tracking
- Assessment integration

### Decorators (decorators.py)

#### 1. Authentication Decorator
```python
def login_required(f):
    """Decorator to require login for routes."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            logger.info("Unauthorized access attempt - redirecting to login")
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function
```
Features:
- Session validation
- Route protection
- Automatic redirection
- Logging integration

### Utility Functions Usage

#### 1. Database Operations
```python
# Get database connection
db = get_db()

# Execute query
result = db.execute('SELECT * FROM users WHERE id = ?', (user_id,)).fetchone()

# Close connection
close_db()
```

#### 2. Authentication
```python
@app.route('/protected')
@login_required
def protected_route():
    return "This route is protected"
```

#### 3. File Upload
```python
def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
```

### Error Handling

#### 1. Database Errors
```python
try:
    db = get_db()
    # Database operations
except sqlite3.Error as e:
    logger.error(f"Database error: {str(e)}")
    raise
```

#### 2. File Upload Errors
```python
try:
    if file and allowed_file(file.filename):
        if file.content_length > MAX_FILE_SIZE:
            raise ValueError("File too large")
except Exception as e:
    logger.error(f"File upload error: {str(e)}")
    raise
```

### Logging Configuration

#### 1. Logger Setup
```python
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
```

#### 2. Log Messages
```python
# Info level
logger.info("Operation completed successfully")

# Error level
logger.error(f"Error occurred: {str(e)}")

# Debug level
logger.debug("Debug information")
```

